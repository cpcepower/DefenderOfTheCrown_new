; ------------------------------------------------------------------------------; from BIBLI.ASM; ---------------------------;Bibliotheque de routines polyvalentes; ---------------------------; pause en dixiemes de secondes; a -> nombre de dixiemesmilpause:; ---------------------------	eimilpaus0	halt:halt:halt	dec a	jr nz,milpaus0	ret;; ---------------------------; Aiguillage du programme selon une table de sous-programmes; A -> Numero du sous-programme; HL-> Adresse de la tableaiguille:; ---------------------------	dec a	call rdtab16	jp (hl); ---------------------------; Calcul d'une valeur aleatoire entre 1 et A; a -> valeur maximum (0 -> 31); a <- nombre aleatoire entre 1 et la valeur maxirandom:; ---------------------------	push bc	ld c,a	ld	a,r	and	#b8		; mask non feedback bits	scf			; set carry	jp	po,no_clr	; skip clear if odd	ccf			; complement carry (clear it)no_clrr_seed equ $ +1	ld	a,1		; prng seed byte (must not be zero)	rla			; rotate carry into byte	ld	(r_seed),a	; save back for next prn; optim -> reduced at max %00011111 &1f = 31; max call in dotc-> a=21	and %00011111rnd_reduce	sub c	jr nc,rnd_reduce	add c	inc a	pop bc	ret; ---------------------------;Renvoie dans HL l'adresse de la variable courante et decale le pointeur IX;de la pile des variables sur la variable suivante;GETVAR  - Lecture de la variable courante;  INPUT - IX-> Pointeur des variables;  OUTPUT- HL-> Valeur de la variable;	 IX-> Pointeur sur variable suivanteGETVAR	LD  L,(IX+00)	LD  H,(IX+01)	INC IX	INC IX	RET; ---------------------------; lecture d'une table de mots 16 bits; hl-> adresse de la table; a -> numero de la valeur (0 -> 127); hl<- valeur 16 bitsrdtab16:; ---------------------------	push af	add a,a	add a,l	ld l,a	adc a,h	sub a,l	ld h,a	ld  a,(hl)	inc hl	ld  h,(hl)	ld  l,a	pop af	ret; ---------------------------; a -> 0 -> 63; hl-> table ptr début; hl<- table ptr ciblerdtab_4:; ---------------------------	dec a	add a,a	add a,a	add a,l	ld l,a	adc a,h	sub a,l	ld h,a	ret; ---------------------------; Lecture d'un tableau; HL-> Adresse debut tableau; DE-> Longueur d'un element; A -> Numero de la case; HL<- ValeurRDTAB; ---------------------------	PUSH AFRDTABCL DEC A	JR  Z,RDTABF	ADD HL,DE	JR  RDTABCLRDTABF  POP AF	RET; ---------------------------; Acces a une chaine dans un tableau; HL-> Adresse du debut du tableau; A -> Numero de la chaine recherchee; HL<- Adresse de la chaine rechercheegetstr; ---------------------------	push af	push bc	ld b,a	ld a,#ffgetstr0	dec b	jr z,getstr3getstr1	cp (hl)	inc hl	jr z,getstr0	jr getstr1getstr3	pop bc	pop af	ret; ---------------------------; Lecture de l'etat du joystick; a  <- etat du joystick (0->u 1->d 2->l 3->r) et carry indique firegetjoy:; ---------------------------	ld a,(keyboard_a_key_pressed)	or a	ret z;	space, copy, return, enter and arrow keys; carry flag is cleared by or a	ld a,(keyboard_line_press+keyboard_line_0)	bit key_enter,a	jr z,keyboard_not_key_enter	scf	retkeyboard_not_key_enter	bit key_down,a	jr z,keyboard_not_key_down	ld a,2	retkeyboard_not_key_down	bit key_right,a	jr z,keyboard_not_key_right	ld a,8	retkeyboard_not_key_right	bit key_up,a	jr z,keyboard_not_key_up	ld a,1	retkeyboard_not_key_up	ld a,(keyboard_line_press+keyboard_line_1)	bit key_left,a	jr z,keyboard_not_key_left	ld a,4	retkeyboard_not_key_left	bit key_copy,a	jr z,keyboard_not_key_copy	scf	retkeyboard_not_key_copy	ld a,(keyboard_line_press+keyboard_line_2)	bit key_return,a	jr z,keyboard_not_key_return	scf	retkeyboard_not_key_return	ld a,(keyboard_line_press+keyboard_line_5)	bit key_space,a	jr z,keyboard_not_key_space	scf	retkeyboard_not_key_space	ld a,(keyboard_line_press+keyboard_line_9)	bit key_joy_0_fire1,a	jr z,keyboard_not_key_joy_0_fire1	res key_joy_0_fire1,a	scfkeyboard_not_key_joy_0_fire1	bit key_joy_0_fire2,a	jr z,keyboard_not_key_joy_0_fire2	res key_joy_0_fire2,a	scfkeyboard_not_key_joy_0_fire2keyboard_test_key_end	ld (LASTJOY),a	ret; ---------------------------; Commutation du mode repeatREPONOFF; ---------------------------	push afkey_repeat	ld a,0	xor #ff	ld (key_repeat),a	pop af	ret; ---------------------------; Attend A secondes ou jusqu'a la pression d'une touche; a  <- Touche presse si différent de zerowait_pause:; ---------------------------	ei	push af	push bc	push hl	ld b,await_pause0	ld hl,300wait_pause1	halt	call getjoy	jr c,wait_pause_end	dec hl	ld a,h	or l	jr nz,wait_pause1	djnz wait_pause0wait_pause_end	pop hl	pop bc	pop af	ret; ---------------------------; diminue une valeur selon un pourcentage; hl -> valeur initiale; b  -> pourcentage; hl <- nouvelle valeurDIMINUE; ---------------------------	push af	push bc	push de	push ix	push hl	ld ix,DIMRESU	ld (ix+00),0	ld (ix+01),0	ld (ix+02),0	ld c,b	ld b,8	ld e,0dimbcle srl c	jr nc,dimnocar	ld a,(ix+00)	add a,l	ld (ix+00),a	ld a,(ix+01)	adc a,h	ld (ix+01),a	ld a,(ix+02)	adc a,e	ld (ix+02),adimnocar	sla l	rl h	rl e	djnz dimbcle	pop hl	ld de,(DIMRESU+1)	or a	sbc hl,de	pop ix	pop de	pop bc	pop af	ret; ---------------------------; multiplie un 16 bits par un 8 bits; hl -> multiplicande; b  -> multiplicateur; hl <- resultatmult; ---------------------------	push de	push bc	ex de,hl	ld hl,0	ld c,b	ld b,8multbcle rr c	jr nc,multno	add hl,de	jr nc,multno	or a	sbc hl,de	retmultno sla e	rl d	djnz multbcle	pop bc	pop de	ret; ---------------------------; divise un 16 bits par un 8 bits; hl -> dividande; b  -> diviseur; hl <- resultatdiv; ---------------------------	ld a,l	ld l,h	ld h,0	ld d,b	ld e,0	call div0	push hl	ld l,a	call div0	ld a,l	pop hl	ld h,l	ld l,a	retdiv0	ld b,8divbcl	add hl,hl	or a	sbc hl,de	inc hl	jr nc,nxt	add hl,de	dec hlnxt	djnz divbcl	ret