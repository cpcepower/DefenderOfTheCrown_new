; ------------------------------------------------------------------------------; from FLECHE.ASM; ---------------------------; Gestion de la fleche; ---------------------------; Affichage de la fleche aux coordonnees courantes si elle est absente*afleche; ---------------------------	push af	ld a,(flstate)	or a	jr nz,afleche0	push bc	push de	push hl	push ix	push iy	ld h,a	ld d,a	ld a,(flcol)	ld l,a	add hl,hl	ex de,hl	ld a,(flrow)	ld l,a	call SCR_DOT_POSITION	; #bc1d	ld (fladd),hl	call scrmem	call wait_vbl	call flon	pop iy	pop ix	pop hl	pop de	pop bcafleche0	pop af	ret; ---------------------------; Effacement de la fleche si elle est presenteefleche; ---------------------------	push af	ld a,(flstate)	or a	jr z,efleche0	push bc	push de	push hl	call wait_vbl	ld hl,(fladd)	call memscr	pop hl	pop de	pop bcefleche0	pop af	ret; ---------------------------; hl <- coordonnees ecran de la flechegflech1; ---------------------------	ld hl,(flrow)	ret; ---------------------------; hl <- adresse ecran de la flechegflech2; ---------------------------	ld hl,(fladd)	ret; ---------------------------; a  <- le contenu de l'octet ecran pointe par la flechetfleche; ---------------------------	push hl	ld hl,(fladd)	ld a,(hl)	pop hl	ret; ---------------------------; Deplace la fleche une fois selon l'etat du joystick.; Cette routine gere la vitesse de deplacement en la reinitialisant *; si la CARRY est non nulle en entree et en l'augmentant tous les huit*; appels sinon.; A contient l'etat du joystickmfleche; ---------------------------	push bc	push de	push hl	push ix	push iy	jr nc,notoff	ld a,1	ld (flvit),a	ld (flvitfl),anotoff	call getjoy	push af	ld d,0	ld c,a	ld a,(flvit)	ld b,a	ld hl,(fladd)	rr c	jr nc,notup	inc d	ld a,(flrow)	add a,b	cp 200	jr c,upnocar	ld a,199upnocar	ld (flrow),anotup	rr c	jr nc,notdn	inc d	ld a,(flrow)	sub b	jr c,dncar	cp 4	jr nc,dnnocardncar	ld a,4dnnocar	ld (flrow),anotdn	rr c	jr nc,notlt	inc d	ld a,(flcol)	sub b	jr nc,ltnocar	ld a,0ltnocar ld (flcol),anotlt rr c	jr nc,notrt	inc d	ld a,(flcol)	add a,b	cp 154	jr c,rtnocar	ld a,153rtnocar	ld (flcol),anotrt	ld a,d	or a	jr nz,chngvit	ld a,1	ld (flvit),a	ld (flvitfl),a	jr nomovechngvit	ld ix,flvitfl	rlc (ix+00)	jr nc,tomove	inc (ix+01)	bit 3,(ix+01)	jr z,tomove	rrc (ix+01)tomove	xor a	ld h,a	ld d,a	ld a,(flcol)	ld l,a	add hl,hl	ex de,hl	ld a,(flrow)	ld l,a	call SCR_DOT_POSITION	; #bc1d	push hl	call wait_vbl	ld hl,(fladd)	call memscr	pop hl	ld (fladd),hl	call scrmem	call flonnomove	pop af	pop iy	pop ix	pop hl	pop de	pop bc	ret; ---------------------------flon; ---------------------------	ld hl,(fladd)	ld a,1	ld (flstate),a	ld de,sword0	ld a,(flcol)	rra	jr nc,floneven	ld de,sword1floneven	ld a,(flrow)	inc a	cp 19	jr c,flon10	ld a,18flon10	ld c,aflon0	ld b,4	push hlflon1	ld a,(de)	rrca	rrca	rrca	rrca	and #f0	cpl	and (hl)	ld (hl),a	ld a,(de)	or (hl)	ld (hl),a	inc de	inc hl	djnz flon1	pop hl	call nextline	dec c	jr nz,flon0	ret;; ---------------------------scrmem; ---------------------------	ld de,flbuf	ld b,18scrmem0	push hl	ld c,4	ldi	ldi	ldi	ldi	pop hl	call nextline	djnz scrmem0	ret; ---------------------------memscr; ---------------------------	xor a	ld (flstate),a	ld de,flbuf	ld b,18memscr0	push hl	ex de,hl	ld c,4	ldi	ldi	ldi	ldi	ex de,hl	pop hl	call nextline	djnz memscr0	ret;